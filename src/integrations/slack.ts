import type { StructuredDiff } from '../analysis/structure-grouper';

export interface SlackBlock {
  type: string;
  text?: {
    type: string;
    text: string;
    emoji?: boolean;
  };
  elements?: Array<{
    type: string;
    text?: string | { type: string; text: string; emoji?: boolean };
    url?: string;
    action_id?: string;
  }>;
  fields?: Array<{
    type: string;
    text: string;
  }>;
  accessory?: {
    type: string;
    text: { type: string; text: string; emoji?: boolean };
    url: string;
    action_id: string;
  };
}

export interface SlackMessage {
  blocks: SlackBlock[];
  text: string; // Fallback text for notifications
}

/**
 * Format a recap as a Slack Block Kit message
 */
export function formatSlackMessage(
  structured: StructuredDiff,
  fileName: string,
  dateRange: { from: string; to: string },
  figmaFileUrl?: string
): SlackMessage {
  const totalChanges = structured.pageStats.reduce((sum, p) => sum + p.changes, 0);
  const totalAdded = structured.pageStats.reduce((sum, p) => sum + p.breakdown.added, 0);
  const totalModified = structured.pageStats.reduce((sum, p) => sum + p.breakdown.modified, 0);
  const totalRemoved = structured.pageStats.reduce((sum, p) => sum + p.breakdown.removed, 0);

  const blocks: SlackBlock[] = [];

  // Header
  blocks.push({
    type: 'header',
    text: {
      type: 'plain_text',
      text: `Design Recap: ${fileName}`,
      emoji: true,
    },
  });

  // Date range context
  blocks.push({
    type: 'context',
    elements: [
      {
        type: 'mrkdwn',
        text: `${formatDate(dateRange.from)} â†’ ${formatDate(dateRange.to)}`,
      },
    ],
  });

  // Summary section
  blocks.push({
    type: 'section',
    text: {
      type: 'mrkdwn',
      text: `*${totalChanges.toLocaleString()} total changes*\n+${totalAdded} added  â€¢  ~${totalModified} modified  â€¢  -${totalRemoved} removed`,
    },
  });

  // Divider
  blocks.push({ type: 'divider' });

  // Top areas of work
  const topSections = structured.pageStats.slice(0, 4);
  if (topSections.length > 0) {
    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: '*Top Areas*',
      },
    });

    const areasText = topSections
      .map((section) => {
        const icon = section.breakdown.added > 10 ? 'ðŸ†•' : 'ðŸ“';
        return `${icon} *${section.name}* â€” ${section.changes} changes`;
      })
      .join('\n');

    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: areasText,
      },
    });
  }

  // Component highlights
  const newComponents = structured.componentGroups.filter(
    (g) => g.stats.added > 0 && g.stats.removed === 0
  );
  const updatedComponents = structured.componentGroups.filter((g) => g.stats.modified > 0);

  if (newComponents.length > 0 || updatedComponents.length > 0) {
    blocks.push({ type: 'divider' });

    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: '*Components*',
      },
    });

    const componentLines: string[] = [];

    if (newComponents.length > 0) {
      const topNew = newComponents.slice(0, 3);
      topNew.forEach((c) => {
        componentLines.push(`âœ¨ *${c.name}* â€” ${c.stats.added} new variants`);
      });
      if (newComponents.length > 3) {
        componentLines.push(`_...and ${newComponents.length - 3} more new components_`);
      }
    }

    if (updatedComponents.length > 0) {
      const topUpdated = updatedComponents.slice(0, 2);
      topUpdated.forEach((c) => {
        componentLines.push(`ðŸ”„ *${c.name}* â€” ${c.stats.modified} updated`);
      });
    }

    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: componentLines.join('\n'),
      },
    });
  }

  // View in Figma button
  if (figmaFileUrl) {
    blocks.push({ type: 'divider' });
    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: ' ',
      },
      accessory: {
        type: 'button',
        text: {
          type: 'plain_text',
          text: 'View in Figma',
          emoji: true,
        },
        url: figmaFileUrl,
        action_id: 'view_figma',
      },
    });
  }

  // Footer
  blocks.push({
    type: 'context',
    elements: [
      {
        type: 'mrkdwn',
        text: '_Generated by RecapMe_',
      },
    ],
  });

  // Fallback text for notifications
  const fallbackText = `Design Recap: ${fileName} â€” ${totalChanges} changes (${dateRange.from} to ${dateRange.to})`;

  return {
    blocks,
    text: fallbackText,
  };
}

/**
 * Post a message to Slack via incoming webhook
 * Slack webhooks don't support CORS, so we generate a copyable message instead
 */
export async function postToSlack(webhookUrl: string, message: SlackMessage): Promise<{ success: boolean; fallbackText?: string }> {
  try {
    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(message),
    });

    // Slack returns 'ok' as text on success
    const text = await response.text();
    if (response.ok || text === 'ok') {
      return { success: true };
    }
    
    throw new Error(`Slack returned: ${text}`);
  } catch (error) {
    // CORS error - return fallback text for manual sharing
    return { 
      success: false, 
      fallbackText: message.text 
    };
  }
}

/**
 * Generate a plain text version of the recap for manual sharing
 */
export function generateSlackText(
  structured: StructuredDiff,
  fileName: string,
  dateRange: { from: string; to: string },
  figmaFileUrl?: string
): string {
  const totalChanges = structured.pageStats.reduce((sum, p) => sum + p.changes, 0);
  const totalAdded = structured.pageStats.reduce((sum, p) => sum + p.breakdown.added, 0);
  const totalModified = structured.pageStats.reduce((sum, p) => sum + p.breakdown.modified, 0);
  const totalRemoved = structured.pageStats.reduce((sum, p) => sum + p.breakdown.removed, 0);

  let text = `*Design Recap: ${fileName}*\n`;
  text += `${formatDate(dateRange.from)} â†’ ${formatDate(dateRange.to)}\n\n`;
  text += `*${totalChanges.toLocaleString()} total changes*\n`;
  text += `+${totalAdded} added  â€¢  ~${totalModified} modified  â€¢  -${totalRemoved} removed\n\n`;

  // Top areas
  const topSections = structured.pageStats.slice(0, 4);
  if (topSections.length > 0) {
    text += `*Top Areas:*\n`;
    topSections.forEach((section) => {
      text += `â€¢ ${section.name} â€” ${section.changes} changes\n`;
    });
    text += `\n`;
  }

  // Components
  const newComponents = structured.componentGroups.filter(
    (g) => g.stats.added > 0 && g.stats.removed === 0
  ).slice(0, 3);
  
  if (newComponents.length > 0) {
    text += `*New Components:*\n`;
    newComponents.forEach((c) => {
      text += `â€¢ ${c.name} â€” ${c.stats.added} variants\n`;
    });
    text += `\n`;
  }

  if (figmaFileUrl) {
    text += `View in Figma: ${figmaFileUrl}`;
  }

  return text;
}

/**
 * Validate a Slack webhook URL format
 */
export function validateSlackWebhook(url: string): boolean {
  return /^https:\/\/hooks\.slack\.com\/services\/[A-Z0-9]+\/[A-Z0-9]+\/[a-zA-Z0-9]+$/.test(url);
}

/**
 * Format date for display
 */
function formatDate(dateStr: string): string {
  const date = new Date(dateStr);
  return date.toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric',
  });
}
